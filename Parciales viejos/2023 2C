##1-a-

n_simpson = function(a, b, max_f4, error) {
n <- ceiling(((b - a)^5 * max_f4 / (180 * error))^(1/4))
if (n %% 2 != 0) {
n <- n + 1  # Asegurarse de que n es par
}
return(n)
}

n_simpson(0, 2, 1.125, 0.001)

IntegracionCompuestaDiscreta <- function(x, y, n, cantIntervalos) {
  # Verificar que los vectores x e y tengan la misma longitud
  if (length(x) != length(y)) {
    stop("Los vectores x e y deben tener la misma longitud.")
  }
  
  # Asegurarse de que la cantidad de intervalos sea menor o igual al total de intervalos disponibles
  if (cantIntervalos > length(x) - 1) {
    stop("La cantidad de intervalos es mayor que el número de puntos disponibles.")
  }
  
  # Determinar el paso para reducir los puntos según la cantidad de intervalos deseada
  step <- floor((length(x) - 1) / cantIntervalos)
  
  # Seleccionar los puntos y valores correspondientes a los intervalos deseados
  x <- x[seq(1, length(x), by = step)]
  y <- y[seq(1, length(y), by = step)]
  
  # Recalcular el número de intervalos y el tamaño de paso h
  cantIntervalos <- length(x) - 1
  h <- (x[length(x)] - x[1]) / cantIntervalos
  
  # Verificar si n es adecuado para el número de intervalos
  if (n == 2 && cantIntervalos %% 2 != 0) {
    stop("El número de intervalos debe ser par para el método de Simpson.")
  }
  
  # Inicializar el resultado
  resultado <- 0
  
  # Aplicar la fórmula compuesta según el método
  if (n == 1) {
    # Método del trapecio compuesto
    resultado <- (h / 2) * (y[1] + 2 * sum(y[2:cantIntervalos]) + y[length(y)])
  } else if (n == 2) {
    # Método de Simpson compuesto
    resultado <- (h / 3) * (y[1] + 4 * sum(y[seq(2, cantIntervalos, by = 2)]) + 2 * sum(y[seq(3, cantIntervalos - 1, by = 2)]) + y[length(y)])
  }
  
  return(resultado)
}

IntegracionCompuestaDiscreta(x = seq(0, 2, by = 0.25), y = c(0.75, 0.8, 0.857, 0.923, 1, 1.091, 1.2, 1.333, 1.5), n = 2, cantIntervalos = 4)

##b-

PolinomioLagrange <- function(x, fx) {
  
  n <- length(x)  # Número de puntos
  l <- rep("", times = n)  # Vector para almacenar los polinomios de Lagrange
  resultado <- ""  # Iniciamos el resultado vacío
  
  # Calculamos cada uno de los polinomios de Lagrange L_i(x)
  for (i in 1:n) {
    l[i] <- "1"  # Inicializamos cada L_i(x) con 1
    for (j in 1:n) {
      if (j != i) {
        l[i] <- paste0(l[i], "* (x - ", x[j], ") / (", x[i], " - ", x[j], ")")
      }
    }
  }
  
  # Sumamos los términos, multiplicando por f(x_i)
  for (i in 1:n) {
    resultado <- paste0(resultado, " + ", fx[i], "*", l[i])
  }
  
  return(paste("El polinomio de Lagrange es: ", resultado))
}

Lagrange = function(x_i, f_i, x) {
n = length(x_i)
aux.1 = rep(NA, n)
aux.2 = rep(NA, n)
for(i in 1:n) {
resta = x - x_i[-i]
aux.1[i] = prod(resta)
resta.2 = x_i[i]-x_i[-i]
aux.2[i] = prod(resta.2)
}
L = aux.1/aux.2
rdo_interpolacion = sum(L * f_i)
return(rdo_interpolacion)
}

x_1 = seq(1, 2, by = 0.25)
f_1 = c(0.515, 0.56, 0.615, 0.682, 0.765)
x1 = 1.9

PolinomioLagrange(x_1, f_1)
Lagrange(x_1,f_1,x1)

x2 = 2.1

Lagrange(x_1,f_1,x2)

##2-a-

library (glue)

TrazadorCubicoNatural = function(x,y){
n = length(y)
if (n < 2) {
stop("Se necesitan al menos dos puntos para generar un spline.")
}
if (n == 2) {
# Caso especial para dos puntos: el spline es una recta
cat("Spline para dos puntos es una línea recta entre los puntos.\n\n")
cat(glue("S1(x) = {y[1]} + ({y[2]} - {y[1]}) / ({x[2]} - {x[1]}) * (x - {x[1]})\n"))
return()  # Termina la ejecución aquí si solo hay dos puntos
}
j = n - 1
a = y
b = c(rep(NA,n))
c = c(rep(NA,n))
d = c(rep(NA,n))
A = c(rep(0,n))
h = c(rep(0,n))
l = c(rep(0,n))
u = c(rep(0,n))
z = c(rep(0,n))
#Paso 1
for (i in 1:j) {
h[i] = x[i + 1] - x[i]
}
#Paso 2
for (i in 2:j) {
A[i] = (3 * (a[i + 1] - a[i])/(h[i])) - (3 * (a[i] - a[i - 1]) /h[i - 1])
}
#Paso 3
l[1] = 1
u[1] = 0
z[1] = 0
#Paso 4
for (i in 2:j) {
l[i] = 2 * (x[i + 1] - x[i - 1]) - h[i - 1] * u[i - 1]
u[i] = h[i]/l[i]
z[i] = (A[i] - h[i - 1] * z[i - 1])/l[i]
}
#Paso 5
l[n] = 1
z[n] = 0
c[n] = 0
#Paso 6
for (i in seq(j, 1, by = -1)) {
c[i] = z[i] - u[i] * c[i + 1]
b[i] = (a[i + 1] - a[i])/h[i] - h[i] * (c[i + 1] + 2*c[i])/3
d[i] = (c[i + 1] - c[i])/(3*h[i])
}
#Paso 7
results = matrix(rep(NA, 4 * j), nrow = j, ncol = 4, byrow = FALSE)
for (k in 1:j) {
results[k, 1] = a[k]
results[k, 2] = b[k]
results[k, 3] = c[k]
results[k, 4] = d[k]
}
#Construyo el polinomio
polinomios = rep(NA, times = j)
for (i in 1:j) {
polinomio = paste0("S", i, "(x) = ", results[i, 1])
for(k in 2:4){
polinomio = paste0(polinomio, glue(" + {results[i, k]} * (x - {x[i]})^{k - 1}"))
}
intervalo = paste0("\nIntervalo: [", x[i], "; ", x[i + 1], "]")
polinomios[i] = paste(polinomio, intervalo)
}
for (p in polinomios) {
    cat(p, "\n\n")
}
}

print(TrazadorCubicoNatural(x = c(1, 2), y = c(1, 2)))
