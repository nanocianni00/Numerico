##1-a-

simpson_compuesto <- function(limiteInferior, limiteSuperior, funcion, n) {
  h <- (limiteSuperior - limiteInferior) / n
  suma <- 0
  for (i in 1:(n/2)) {
    xi <- limiteInferior + (2*i - 2)*h
    xi_1 <- limiteInferior + (2*i - 1)*h
    xi_2 <- limiteInferior + 2*i*h
    
    fx0 <- eval(funcion, list(x = xi))
    fx1 <- eval(funcion, list(x = xi_1))
    fx2 <- eval(funcion, list(x = xi_2))
    
    suma <- suma + (h / 3) * (fx0 + 4 * fx1 + fx2)
  }
  return(suma)
}

simpson_compuesto(limiteInferior = 0, limiteSuperior = 1000, funcion = expression(x^8.22 * exp(-x)), n = 100)

##b-

##2-a-

set.seed(123)
P0 <- 75            # Precio inicial
mu <- 0.15           # Tasa de rendimiento esperada
sigma <- 0.2           # Volatilidad
T <- 1               # Tiempo en años
pasos <- 180         # Número de pasos (360 días)
n_sim <- 1000        # Número de simulaciones

Pt <- matrix(0, nrow = n_sim, ncol = pasos + 1)
Pt[, 1] <- P0
dt <- T / pasos

for (i in 1:n_sim) { # cuenta el numero de simulacion
  for (j in 2:(pasos + 1)) {
    Pt[i, j] <- Pt[i, j - 1] * exp((mu - 0.5 * sigma^2) * dt + sigma * sqrt(dt) * rnorm(1)) # rnorm(1) genera un numero aleatorio (es el epsilon de la formula)
  }
}
  e<-rnorm(n_sim)
  Pt<-matrix(NA,nrow=n_sim,ncol=1)
  Pt<-P0 * exp((mu - 0.5 * sigma^2) * 0.5 + sigma * sqrt(dt) * e)
  hist(Pt)

##b-

